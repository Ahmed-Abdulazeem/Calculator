Description	Resource	Path	Location	Type
#1376-D (MISRA-C:2004 1.1/R) Ensure strict ANSI C mode (-ps) is enabled	Platform_Types.h	/CaluclatorMISRA/4.LIB	line 22	C/C++ Problem
#1392-D (MISRA-C:2004 9.3/R) In an enumerator list, the '=' construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised	Std_Types.h	/CaluclatorMISRA/4.LIB	line 55	C/C++ Problem
#1393-D (MISRA-C:2004 10.1/R) The value of an expression of integer type shall not be implicitly converted to a different underlying type if it is not a conversion to a wider integer type of the same signedness	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 98	C/C++ Problem
#1393-D (MISRA-C:2004 10.1/R) The value of an expression of integer type shall not be implicitly converted to a different underlying type if it is not a conversion to a wider integer type of the same signedness	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 119	C/C++ Problem
#1393-D (MISRA-C:2004 10.1/R) The value of an expression of integer type shall not be implicitly converted to a different underlying type if it is not a conversion to a wider integer type of the same signedness	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 275	C/C++ Problem
#1393-D (MISRA-C:2004 10.1/R) The value of an expression of integer type shall not be implicitly converted to a different underlying type if the expression is complex	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 98	C/C++ Problem
#1393-D (MISRA-C:2004 10.1/R) The value of an expression of integer type shall not be implicitly converted to a different underlying type if the expression is complex	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 119	C/C++ Problem
#1394-D (MISRA-C:2004 10.2/R) The value of an expression of floating type shall not be implicitly converted to a different type if the expression is complex	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 280	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 66	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 95	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 96	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 98	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 101	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 116	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 117	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 119	C/C++ Problem
#1397-D (MISRA-C:2004 10.5/R) If the bitwise operators ~ and << are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 122	C/C++ Problem
#1400-D (MISRA-C:2004 11.3/A) A cast should not be performed between a pointer type and an integral type	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 30	C/C++ Problem
#1406-D (MISRA-C:2004 12.7/R) Bitwise operators shall not be applied to operands whose underlying type is signed	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 98	C/C++ Problem
#1406-D (MISRA-C:2004 12.7/R) Bitwise operators shall not be applied to operands whose underlying type is signed	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 119	C/C++ Problem
#1411-D (MISRA-C:2004 13.3/R) Floating-point expressions shall not be tested for equality or inequality	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 247	C/C++ Problem
#1422-D (MISRA-C:2004 16.9/R) A function identifier shall only be used with either a preceding &, or with a parenthesised parameter list, which may be empty (function "EXTIB0_CallBack")	KeyPad.c	/CaluclatorMISRA/2-HAL/KeyPad	line 76	C/C++ Problem
#1422-D (MISRA-C:2004 16.9/R) A function identifier shall only be used with either a preceding &, or with a parenthesised parameter list, which may be empty (function "EXTIB1_CallBack")	KeyPad.c	/CaluclatorMISRA/2-HAL/KeyPad	line 77	C/C++ Problem
#1422-D (MISRA-C:2004 16.9/R) A function identifier shall only be used with either a preceding &, or with a parenthesised parameter list, which may be empty (function "EXTIB2_CallBack")	KeyPad.c	/CaluclatorMISRA/2-HAL/KeyPad	line 78	C/C++ Problem
#1422-D (MISRA-C:2004 16.9/R) A function identifier shall only be used with either a preceding &, or with a parenthesised parameter list, which may be empty (function "EXTIB3_CallBack")	KeyPad.c	/CaluclatorMISRA/2-HAL/KeyPad	line 79	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 23	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 24	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 25	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 26	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 27	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 28	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 29	C/C++ Problem
#1428-D (MISRA-C:2004 19.7/A) A function should be used in preference to a function-like macro	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 31	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "BIT_NO" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 28	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "Offset" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 27	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "Offset" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 29	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "REG" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 27	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "REG" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 28	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "REG" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 29	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "REG" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 31	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "VALUE" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 28	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "VALUE" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 29	C/C++ Problem
#1430-D (MISRA-C:2004 19.10/R) In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##. The compiler cannot determine if the parameter "VALUE" is used as an operand of # or ##.	Bit_Math.h	/CaluclatorMISRA/4.LIB	line 31	C/C++ Problem
#1435-D (MISRA-C:2004 20.1/R) Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined ("NULL")	Std_Types.h	/CaluclatorMISRA/4.LIB	line 24	C/C++ Problem
#1473-D (MISRA-C:2004 16.4/R) The identifiers used in the declaration and definition of a function shall be identical	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 112	C/C++ Problem
#1476-D (MISRA-C:2004 17.4/R) Array indexing shall be the only allowed form of pointer arithmetic	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 163	C/C++ Problem
#1476-D (MISRA-C:2004 17.4/R) Array indexing shall be the only allowed form of pointer arithmetic	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 172	C/C++ Problem
#1483-D (MISRA-C:2004 12.6/A) Expressions that are effectively Boolean should not be used in operations with expressions that are not effectively Boolean	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 240	C/C++ Problem
#1483-D (MISRA-C:2004 12.6/A) Expressions that are effectively Boolean should not be used in operations with expressions that are not effectively Boolean	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 262	C/C++ Problem
#1483-D (MISRA-C:2004 12.6/A) Expressions that are effectively Boolean should not be used in operations with expressions that are not effectively Boolean	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 273	C/C++ Problem
#1483-D (MISRA-C:2004 12.6/A) Expressions that are effectively Boolean should not be used in operations with expressions that are not effectively Boolean	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 280	C/C++ Problem
#1483-D (MISRA-C:2004 12.6/A) Expressions that are effectively Boolean should not be used in operations with expressions that are not effectively Boolean	LCD.c	/CaluclatorMISRA/2-HAL/LCD	line 290	C/C++ Problem
#1487-D (MISRA-C:2004 12.2/R) The value of an expression shall be the same under any order of evaluation that the standard permits	Calculator.c	/CaluclatorMISRA/3-APP/Calculator	line 209	C/C++ Problem
#1487-D (MISRA-C:2004 12.2/R) The value of an expression shall be the same under any order of evaluation that the standard permits	Calculator.c	/CaluclatorMISRA/3-APP/Calculator	line 252	C/C++ Problem
#1497-D (MISRA-C:2004 5.7/A) No identifier name should be reused ("Pin")	EXTI_Interface.h	/CaluclatorMISRA/1.MCAL/EXTI/INC	line 58	C/C++ Problem
#1497-D (MISRA-C:2004 5.7/A) No identifier name should be reused ("Port")	EXTI_Interface.h	/CaluclatorMISRA/1.MCAL/EXTI/INC	line 57	C/C++ Problem
#1497-D (MISRA-C:2004 5.7/A) No identifier name should be reused ("Reserved")	TM4C123xx.h	/CaluclatorMISRA/4.LIB	line 82	C/C++ Problem
#1497-D (MISRA-C:2004 5.7/A) No identifier name should be reused ("RIS")	TM4C123xx.h	/CaluclatorMISRA/4.LIB	line 78	C/C++ Problem
#1497-D (MISRA-C:2004 5.7/A) No identifier name should be reused ("Value")	Calculator.c	/CaluclatorMISRA/3-APP/Calculator	line 40	C/C++ Problem
#1498-D (MISRA-C:2004 6.3/A) typedefs that indicate size and signedness should be used in place of the basic numerical types	Delay.h	/CaluclatorMISRA/4.LIB	line 11	C/C++ Problem
#1498-D (MISRA-C:2004 6.3/A) typedefs that indicate size and signedness should be used in place of the basic numerical types	Delay.h	/CaluclatorMISRA/4.LIB	line 12	C/C++ Problem
#1506-D (MISRA-C:2004 13.6/R) Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop	Calculator.c	/CaluclatorMISRA/3-APP/Calculator	line 236	C/C++ Problem
#188-D pointless comparison of unsigned integer with zero	Calculator.c	/CaluclatorMISRA/3-APP/Calculator	line 81	C/C++ Problem
